# Book Store API

REST API для потенциального книжного магазина. Написано
на Spring Web (архитектура MVC) с использованием следующих
зависимостей:

* `lombok` - для сокращения boilerplate кода (геттеров и сеттеров) в классах сущностей
* `mysql-connector-java` - для подключения к базе данных MySQL
* `gson` - для парсинга JSON строк
* `mockito-all` - для тестирования приложения с использованием Mock объектов
* `springdoc-openapi-ui` - для автоматической генерации OpenAPI документации
* `spring-security`- пока только для хэширования паролей пользователей

## Сборка и запуск

Требуемая версия Java - 18.

`mvn clean install` - сгенерирует JAR with dependencies.

Для того, чтобы Вам не запускать предварительно БД для сборки,
положил в корень готовый JAR.

`java -jar target/bookstore-api.jar [data.json] [logs.txt]` - запускает
сервер. Опционально принимает первым аргументом путь к JSON файлу с данными, которые
будут занесены в базу данных при запуске, вторым аргументом -
путь к файлу для записи логов.

Пример содержимого JSON файла:

```json
{
    "accounts": [
        {
            "email": "somebody@somewhere.com",
            "password": "12345678",
            "balance": 100
        }
    ],
    "books": [
        {
            "author": "Стив Макконелл",
            "name": "Совершенный код",
            "price": 1000,
            "amount": 7
        }
    ]
}
```

Требует соединения с внешней базой данных MySQL, поэтому ее
необходимо заранее поднять.
Параметры соединения указываются
в файле `src/main/resources/application.properties`.
Конечно, Hibernate сам создаст нужные таблицы, но на всякий случай положил
SQL дампы структур таблиц в `mysql_dumps`.

### Docker
Для сбрки образа в директории `target` должен находиться созданный на предыдущем шаге JAR файл.
Пути к файлам `data.json` и `logs.txt` прописаны в аргументах запуска в `Dockerfile`.

`docker-compose up` - собирает и запускает сервер вместе с базой
данных.

## Описание реализации
Данный API представляет собой полноценное CRUD-приложение,
т.е. поддерживает создание, чтение, модификацию и удаление сущностей.
(сущностей здесь четыре типа: аккаунт, книга, категория книги и сделка)

Надеюсь, что это не сочтется за отклонение от ТЗ (например,
потому, что API оперирует произвольным количеством сущностей
"Аккаунт", а не одной, как требовалось в задании)

### Структура базы данных
Таблицы Account и Book связаны с таблицей Deal отношением
"many-to-one", аналогично связана таблица BookCategory с таблицей Book
![db schema](https://github.com/timickb/book-store-api/blob/dev/db-schema.png?raw=true)


### Модели (сущности)
Основные модели (`Account`, `Book`, `Deal` и `BookCategory`) наследуются
от базовой `EntityBase`, которая содержит в себе общие для всех
поля: `id` (идентификатор), `created` (дата создания) и `updated` -
дата обновления.

Помимо основных, API оперирует request и response моделями,
которые описывают запросы к серверу и ответы сервера соответстенно.

Для конвертации основных моделей из/в request/response исопльзуются
сервисы `RequestMapper` и `ResponseMapper` соответственно.

### Документация
Полная документация к эндпоинтам и моделям расположена по адресу 
`/api/v1/swagger`.

### Прочие моменты
Эндпоинты отличаются от обозначенных в ТЗ:
* `GET /account` стал `GET /api/v1/accounts/{accountId}`
* `GET /market` стал `GET /api/v1/books` и `POST /api/v1/books/filter` (можно фильтровать поиск)
* `POST /market/deal` стал `POST /api/v1/deals`

Отличается и тело POST запроса на создание сделки,
добавлен идентификатор аккаунта-покупателя. Вот пример:
```json
{
  "book_id": 1,
  "account_id": 1,
  "amount": 4
}
```

Некоторые идеи были взяты из ТЗ к отбору на фронтенд: фильтрация поиска
книг и поле `coverUrl` у книги.
